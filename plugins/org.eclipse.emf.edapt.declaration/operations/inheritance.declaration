<?xml version="1.0" encoding="ASCII"?>
<declaration:Library xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:declaration="http://www.eclipse.org/emf/edapt/declaration/0.3" implementation="inheritance.groovy">
  <operations name="replaceFeature" description="In the metamodel, a feature is replace by another one. In the model, the values are moved accordingly." label="Replace Feature" deprecated="true">
    <parameters classifierName="EStructuralFeature" name="toReplace" description="The feature to be replaced" main="true"/>
    <parameters classifierName="EStructuralFeature" name="replaceBy" description="The feature by which it is replaced" choiceExpression="subClass.eAllStructuralFeatures"/>
    <constraints label="The features must be of the same type" booleanExpression="toReplace.eType == replaceBy.eType "/>
    <constraints label="The features must be of the same cardinality" booleanExpression="toReplace.many == replaceBy.many "/>
    <constraints label="The feature to replace must be defined in a sub class of the one with the feature by which it is replaced" booleanExpression="subClass.eAllStructuralFeatures.contains(replaceBy) "/>
    <variables classifierName="EClass" name="subClass" initExpression="toReplace.eContainingClass"/>
  </operations>
  <operations name="extractSuperClass2" description="In the metamodel, a super class is extracted from a number of sub classes. In the model, nothing is changed." label="Extract Super Class">
    <parameters many="true" classifierName="EClass" name="subClasses" description="The class from which the super class is extracted" main="true"/>
    <parameters many="true" classifierName="EStructuralFeature" name="toExtract" description="The features to be extracted"/>
    <parameters classifierName="EPackage" name="ePackage" initExpression="subClass.ePackage" description="The package in which the super class is created"/>
    <parameters classifierName="EString" name="superClassName" description="The name of the super class"/>
    <parameters classifierName="EBoolean" name="abstr" initExpression="true" description="Whether the super class is abstract"/>
    <parameters many="true" classifierName="EClass" name="superSuperClasses" initExpression="[] " description="The super classes of the sub class which become super classes of the super class"/>
    <constraints label="The features' types have to be the same" booleanExpression="mainFeature == null || toExtract.every{feature -> mainFeature.eType == feature.eType} "/>
    <constraints label="The features' multiplicities have to be the same" booleanExpression="mainFeature == null || toExtract.every{feature -> mainFeature.lowerBound == feature.lowerBound &amp;&amp; mainFeature.upperBound == feature.upperBound} "/>
    <constraints label="The features have to be all containment references or not" booleanExpression="mainFeature == null || mainFeature instanceof EAttribute || toExtract.every{feature -> mainFeature.containment == feature.containment} "/>
    <constraints label="The features must not have opposite references" booleanExpression="mainFeature == null || mainFeature instanceof EAttribute || toExtract.every{feature -> (feature == mainFeature || feature.eOpposite == null)} "/>
    <constraints label="The sub classes must have the super classes as common super classes" booleanExpression="subClasses.every{subClass -> subClass.eSuperTypes.containsAll(superSuperClasses)} "/>
    <variables classifierName="EStructuralFeature" name="mainFeature" initExpression="toExtract.isEmpty() ? null : toExtract[0]"/>
  </operations>
  <operations name="extractSuperClass" description="In the metamodel, a number of features of a class are extracted to a new super class. In the model, nothing is changed." label="Extract Super Class" deprecated="true">
    <parameters classifierName="EClass" name="subClass" description="The class from which the features are extracted" main="true"/>
    <parameters many="true" classifierName="EStructuralFeature" name="toExtract" description="The features to be extracted" choiceExpression="subClass.eStructuralFeatures"/>
    <parameters classifierName="EPackage" name="ePackage" initExpression="subClass.ePackage" description="The package in which the super class is created"/>
    <parameters classifierName="EString" name="superClassName" description="The name of the super class"/>
    <parameters classifierName="EBoolean" name="abstr" initExpression="true" description="Whether the super class is abstract"/>
    <parameters many="true" classifierName="EClass" name="superSuperClasses" initExpression="[] " description="The super classes of the sub class which become super classes of the super class" choiceExpression="subClass.eSuperTypes"/>
    <constraints label="The features to be extracted must belong to sub class" booleanExpression="subClass.eStructuralFeatures.containsAll(toExtract) "/>
    <constraints label="The super classes to be extracted must be a containsAll of the subclass's super types" booleanExpression="subClass.eSuperTypes.containsAll(superSuperClasses) "/>
  </operations>
  <operations name="useSuperClass" description="In the metamodel, a number of features are replaced by features of a new super class. In the model, the values are moved to these features based on a mapping." label="Fold Super Class">
    <parameters classifierName="EClass" name="subClass" description="The class to which the super class is added" main="true"/>
    <parameters classifierName="EClass" name="superClass" description="The new super class"/>
    <parameters many="true" classifierName="EStructuralFeature" name="toReplace" description="The features to be replaced" choiceExpression="subClass.eStructuralFeatures"/>
    <parameters many="true" classifierName="EStructuralFeature" name="replaceBy" description="The features by which they are replaced (in the same order)" choiceExpression="superClass.eAllStructuralFeatures"/>
    <constraints label="The number of features to be replaced and to replace them must be the same" booleanExpression="toReplace.size() == replaceBy.size() "/>
    <constraints label="The features to be replaced must belong to the sub class" booleanExpression="subClass.eStructuralFeatures.containsAll(toReplace) "/>
    <constraints label="The features to replace must be available in the super class" booleanExpression="superClass.eAllStructuralFeatures.containsAll(replaceBy) "/>
    <constraints label="The features must be of the same type" booleanExpression="toReplace.every{it.eType == replaceBy[toReplace.indexOf(it)].eType} "/>
    <constraints label="The features must be of the same multiplicity" booleanExpression="toReplace.every{it.many == replaceBy[toReplace.indexOf(it)].many} "/>
  </operations>
  <operations name="inlineSuperClass" description="In the metamodel, a super class is inlined into its sub classes. More specifically, its features are propagated to the sub classes. In the model, the values of these features have to be adapted accordingly." label="Inline Super Class">
    <parameters classifierName="EClass" name="superClass" description="The super class to be inlined" main="true"/>
    <constraints label="The super class must be abstract" booleanExpression="!isConcrete(superClass) "/>
  </operations>
  <operations name="pullFeature" description="In the metamodel, a number of features are pulled up into a common super class. In the model, values are changed accordingly." label="Pull up Feature">
    <parameters many="true" classifierName="EStructuralFeature" name="features" description="The features to be pulled up" main="true"/>
    <parameters classifierName="EClass" name="targetClass" initExpression="features[0].eContainingClass.eSuperTypes[0] " description="The super class to which the features are pulled"/>
    <constraints label="The features' types have to be the same" booleanExpression="features.every{feature -> mainFeature.eType == feature.eType} "/>
    <constraints label="The features' multiplicities have to be the same" booleanExpression="features.every{feature -> mainFeature.lowerBound == feature.lowerBound &amp;&amp; mainFeature.upperBound == feature.upperBound} "/>
    <constraints label="The features have to be all containment references or not" booleanExpression="mainFeature instanceof EAttribute || features.every{feature -> mainFeature.containment == feature.containment} "/>
    <constraints label="The features must not have opposite references" booleanExpression="mainFeature instanceof EAttribute || features.every{feature -> (feature == mainFeature || feature.eOpposite == null)} "/>
    <constraints label="The features' classes must have a common super type" booleanExpression="features.every{feature -> feature.eContainingClass.eSuperTypes.contains(targetClass)} "/>
    <variables classifierName="EStructuralFeature" name="mainFeature" initExpression="features[0]"/>
  </operations>
  <operations name="pushFeature" description="In the metamodel, a feature is pushed down to its sub classes. In the model, values are changed accordingly." label="Push down Feature" deleting="true">
    <parameters classifierName="EStructuralFeature" name="feature" description="The feature to be pushed down" main="true"/>
    <constraints label="If the feature has an opposite, then the super class may only have one sub type." booleanExpression="feature instanceof EAttribute || feature.eOpposite == null || superClass.eSubTypes.size() == 1 "/>
    <variables classifierName="EClass" name="superClass" initExpression="feature.eContainingClass"/>
    <variables many="true" classifierName="EClass" name="subClasses" initExpression="superClass.getInverse(emf.EClass._eSuperTypes)"/>
  </operations>
  <operations name="inlineSubClass" description="In the metamodel, the sub class is deleted. In the model, all instances of this sub class are migrated to its super class." label="Inline Sub Class">
    <parameters classifierName="EClass" name="subClass" description="The class to be inlined" main="true"/>
    <constraints label="The sub class must have exactly one super type" booleanExpression="subClass.eSuperTypes.size() == 1 "/>
    <constraints label="The sub class must not have sub types" booleanExpression="subClass.eSubTypes.isEmpty() "/>
    <constraints label="The sub class must not have features" booleanExpression="subClass.eStructuralFeatures.isEmpty() "/>
    <constraints label="The super class must not be abstract" booleanExpression="isConcrete(superClass) "/>
    <variables classifierName="EClass" name="superClass" initExpression="subClass.eSuperTypes[0]"/>
  </operations>
  <operations name="extractSubClass" description="In the metamodel, a feature is extracted into a new subclass and the feature is made mandatory. In the model, all instances of the superclass that have the feature set are migrated to the new subclass." label="Extract Subclass">
    <parameters classifierName="EClass" name="superClass" description="The superclass from which the feature is extracted" main="true"/>
    <parameters classifierName="EStructuralFeature" name="feature" description="The feature to be extracted" choiceExpression="superClass.eStructuralFeatures"/>
    <parameters classifierName="EString" name="className" description="The name of the new subclass"/>
    <constraints label="The feature has to belong to the super class" booleanExpression="superClass.eStructuralFeatures.contains(feature) "/>
    <constraints label="The super class may not have a sub class" booleanExpression="superClass.eSubTypes.isEmpty() "/>
  </operations>
  <operations name="imitateSuperType" description="In the metamodel, a superclass is removed from a subclass, while all its features are copied into the subclass. In the model, values are changed accordingly." label="Unfold Superclass">
    <parameters classifierName="EClass" name="subClass" description="The subclass" main="true"/>
    <parameters classifierName="EClass" name="superClass" initExpression="subClass.eSuperTypes[0] " description="The superclass" choiceExpression="subClass.eSuperTypes"/>
    <constraints label="The super class has to be a super type of the sub class" booleanExpression="subClass.eSuperTypes.contains(superClass) "/>
    <constraints label="The super class must not be target of a reference" booleanExpression="superClass.getInverse(emf.ETypedElement.eType).isEmpty() "/>
    <variables many="true" classifierName="EStructuralFeature" name="features" initExpression="superClass.eStructuralFeatures"/>
  </operations>
  <operations name="pullOperation" description="In the metamodel, a number of operations are pulled up into a common super class. In the model, nothing needs to be done." label="Pull up Operation">
    <parameters many="true" classifierName="EOperation" name="operations" description="The operations to be pulled up" main="true"/>
    <parameters classifierName="EClass" name="targetClass" initExpression="operations[0].eContainingClass.eSuperTypes[0] " description="The super class to which the operations are pulled"/>
    <constraints label="The operations' types have to be the same" booleanExpression="operations.every{operation -> mainOperation.eType == operation.eType} "/>
    <constraints label="The operations' multiplicities have to be the same" booleanExpression="operations.every{operation -> mainOperation.lowerBound == operation.lowerBound &amp;&amp; mainOperation.upperBound == operation.upperBound} "/>
    <constraints label="The operations' classes must have a common super type" booleanExpression="operations.every{operation -> operation.eContainingClass.eSuperTypes.contains(targetClass)} "/>
    <variables classifierName="EOperation" name="mainOperation" initExpression="operations[0]"/>
  </operations>
  <operations name="pushOperation" description="In the metamodel, an operation is pushed down to its sub classes. In the model, nothing needs to be done." label="Push down Operation">
    <parameters classifierName="EOperation" name="operation" description="The operation to be pushed down" main="true"/>
  </operations>
</declaration:Library>
